First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.First program. We use the async and await keywords to asynchronously run a method. The program begins a long-running method (HandleFileAsync).
Part 1: We create a Task instance by calling HandleFileAsync. The task starts, and (later in Main) we call Wait() for it to finish.
Part 2: This async method displays a status message, and does some long-running calculations. We use StreamReader and await ReadToEndAsync.
Part 3: We must be careful to call Wait() on the task we want to wait for. Sometimes the wrong Task can be waited on.
Info: Please change the path to a large text file that exists on your computer. Any large text file will do
Task.Run example. This program runs a computation asynchronously on every line entered in the console. It keeps accepting lines even when computations are running.
Action: A lambda expression is specified as the argument to Task.Run. This is an action delegate.
Action
Allocate: This method does a slow-running computation. But when run asynchronously, it does not cause the program to freeze.
Result: Many user inputs can be handled while the computation is running. Each Allocate() call finishes at its own pace.
ContinueWith. In real-world programs, we often need to call one method after another—we create a method chain. The ContinueWith method on Task can be used to call methods sequentially.
Here: From Main, we call the Run2Methods() method 10 times. It asynchronously calls GetSum and then MultiplyNegative1.
Tip: MultiplyNegative1 is always called after GetSum. The ContinueWith method runs its code after the method in Task.Run.
New Task, local method. Suppose we want to run a Task in the background. Some C# syntax features can help here—we can use a local method declaration (InnerMethod in the example).
Main: We call BackgroundMethod, then run some important logic in the for-loop every 100 ms.
BackgroundMethod: Contains a local function InnerMethod. We use the Task constructor to create a new Task.
Then: We invoke Task.Start. Finally we await the task—both methods run at the same time.
Warnings, await operator. If we use async without await, the C# compiler will warn us that we are not accomplishing anything. We must pair the 2 operators. Async methods must contain await.
To fix: Type "await" in front of Task.Run in BackgroundMethod. Note that the program still needs work.
Error, main method. The async keyword cannot be used on the Main method. So we will need to add a second method before using an await call.
Task. This is a class found in System.Threading.Tasks. A Task returns no value (it is void). A Task<int> returns an element of type int. This is a generic type.
Task
Info: We can call Task.Run, ContinueWith, Wait—we can even run Tasks without async and await.
CancellationToken: We use a CancellationTokenSource with tokens to signal a task should exit early.

 
A pattern. Async and await are a code pattern—they allow methods to asynchronously run. They are a form of syntactic sugar. They make code that uses threads easier to read.
Note: An async method will be run synchronously if it does not contain the await keyword.
Compiler. With async and await, the compiler helps with asynchronous code. We return a Task or void from an async method. Visual Studio reports errors on incorrect methods.
Types (StreamReader, HttpClient) contain "Async" methods. These should be called with the await keyword. And the await keyword must be used within an async method.
StreamReader
ReadLine, ReadLineAsync
HttpClient
Task.Start: The first async method call can occur with the Task Start method. This is an instance method.
Also: Event handlers can be used with async methods. This is not currently shown here.
ReadToEndAsync. When can ReadToEndAsync lead to a performance gain in a program? When we have high CPU usage with a file load, we can speed up completion time with async and await.
StreamReader ReadToEndAsync
Notes, terms. Asynchronous does not mean multithreaded code. By default, code written with async and await is single-threaded. But threaded code works well here.
And: With the Task.Run method, we can make code that uses async and await multithreaded.
Important: Other code can execute (even on the same thread) after an asynchronous task has started.
Some corrections. Thanks to Donnie Karns for pointing out that async code statements are not (by default) run on another thread. Thanks to Jim Boyer for correcting a "nested" task problem.
And: Thanks to Andrew Dennison for reviewing the Allocate() method code which had an unnecessary statement.
A review. Programs are full of methods that do not immediately return. Sometimes an external slowdown, as from a network, is the cause, not processor usage.
With these keywords, we run methods in an asynchronous way. Threads are optional. This style of code is more responsive. A network access can occur with no program freeze.